(assume h1 (= a b))
(assume h2 (= b c))
(assume h3 (not (= (k (f a) (g a) (h a)) (k (f b) (g b) (h c)))))
(step t4 (cl (not (= (f a) (f b))) (not (= (g a) (g b))) (not (= (h a) (h c))) (= (k (f a) (g a) (h a)) (k (f b) (g b) (h c)))) :rule eq_congruent)
(step t5 (cl (not (= a b)) (= (f a) (f b))) :rule eq_congruent)
(step t6 (cl (not (= (g a) (g b))) (not (= (h a) (h c))) (= (k (f a) (g a) (h a)) (k (f b) (g b) (h c))) (not (= a b))) :rule th_resolution :premises (t4 t5))
(step t7 (cl (not (= a b)) (= (g a) (g b))) :rule eq_congruent)
(step t8 (cl (not (= (h a) (h c))) (= (k (f a) (g a) (h a)) (k (f b) (g b) (h c))) (not (= a b)) (not (= a b))) :rule th_resolution :premises (t6 t7))
(step t9 (cl (not (= (h a) (h c))) (= (k (f a) (g a) (h a)) (k (f b) (g b) (h c))) (not (= a b))) :rule contraction :premises (t8))
(step t10 (cl (not (= a c)) (= (h a) (h c))) :rule eq_congruent)
(step t11 (cl (not (= a b)) (not (= b c)) (= a c)) :rule eq_transitive)
(step t12 (cl (= (h a) (h c)) (not (= a b)) (not (= b c))) :rule th_resolution :premises (t10 t11))
(step t13 (cl (= (k (f a) (g a) (h a)) (k (f b) (g b) (h c))) (not (= a b)) (not (= a b)) (not (= b c))) :rule th_resolution :premises (t9 t12))
(step t14 (cl (= (k (f a) (g a) (h a)) (k (f b) (g b) (h c))) (not (= a b)) (not (= b c))) :rule contraction :premises (t13))
(step t15 (cl) :rule resolution :premises (t14 h1 h2 h3))
