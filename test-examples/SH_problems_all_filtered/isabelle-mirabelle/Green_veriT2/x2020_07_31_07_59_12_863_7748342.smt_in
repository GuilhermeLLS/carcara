; --index-fresh-sorts --proof-version=2 --proof-prune --proof-merge --disable-print-success --disable-banner --max-time=30
(set-option :produce-proofs true)
(set-logic AUFLIRA)
(declare-sort Real_set$ 0)
(declare-sort Real_real_set_fun$ 0)
(declare-sort Real_real_set_prod$ 0)
(declare-sort Real_real_set_prod_set$ 0)
(declare-sort Real_real_set_prod_bool_fun$ 0)
(declare-sort Real_real_set_prod_real_fun$ 0)
(declare-fun f$ () Real_real_set_prod_real_fun$)
(declare-fun p$ () Real_real_set_prod_set$)
(declare-fun s$ () Real_set$)
(declare-fun snd$ (Real_real_set_prod$) Real_set$)
(declare-fun fine$ (Real_real_set_fun$ Real_real_set_prod_set$) Bool)
(declare-fun pair$ (Real Real_set$) Real_real_set_prod$)
(declare-fun gamma$ () Real_real_set_fun$)
(declare-fun finite$ (Real_set$) Bool)
(declare-fun member$ (Real_real_set_prod$ Real_real_set_prod_set$) Bool)
(declare-fun thesis$ () Bool)
(declare-fun fun_app$ (Real_real_set_prod_real_fun$ Real_real_set_prod$) Real)
(declare-fun member$a (Real Real_set$) Bool)
(declare-fun fun_app$a (Real_real_set_prod_bool_fun$ Real_real_set_prod$) Bool)
(declare-fun interior$ (Real_set$) Real_set$)
(assert (! (not thesis$) :named a0))
(assert (! (forall ((?v0 Real_real_set_prod_real_fun$)) (=> (forall ((?v1 Real_real_set_prod$)) (=> (member$ ?v1 p$) (and (not (member$a (fun_app$ ?v0 ?v1) s$)) (member$a (fun_app$ ?v0 ?v1) (interior$ (snd$ ?v1)))))) thesis$)) :named a1))
(assert (! (forall ((?v0 Real_real_set_prod$)) (=> (member$ ?v0 p$) (exists ((?v1 Real)) (and (not (member$a ?v1 s$)) (member$a ?v1 (interior$ (snd$ ?v0))))))) :named a2))
(assert (! (forall ((?v0 Real) (?v1 Real_set$)) (=> (member$ (pair$ ?v0 ?v1) p$) (and (not (member$a (fun_app$ f$ (pair$ ?v0 ?v1)) s$)) (member$a (fun_app$ f$ (pair$ ?v0 ?v1)) (interior$ ?v1))))) :named a3))
(assert (! (finite$ s$) :named a4))
(assert (! (fine$ gamma$ p$) :named a5))
(assert (! (forall ((?v0 Real_set$)) (= (interior$ (interior$ ?v0)) (interior$ ?v0))) :named a6))
(assert (! (forall ((?v0 Real) (?v1 Real_set$) (?v2 Real) (?v3 Real_set$)) (= (= (pair$ ?v0 ?v1) (pair$ ?v2 ?v3)) (and (= ?v0 ?v2) (= ?v1 ?v3)))) :named a7))
(assert (! (forall ((?v0 Real) (?v1 Real_set$) (?v2 Real) (?v3 Real_set$)) (= (= (pair$ ?v0 ?v1) (pair$ ?v2 ?v3)) (and (= ?v0 ?v2) (= ?v1 ?v3)))) :named a8))
(assert (! (forall ((?v0 Real_real_set_prod$) (?v1 Real) (?v2 Real_set$)) (=> (= ?v0 (pair$ ?v1 ?v2)) (= (snd$ ?v0) ?v2))) :named a9))
(assert (! (forall ((?v0 Real) (?v1 Real_set$) (?v2 Real_set$)) (=> (= (snd$ (pair$ ?v0 ?v1)) ?v2) (= ?v1 ?v2))) :named a10))
(assert (! (forall ((?v0 Real) (?v1 Real_set$)) (! (= (snd$ (pair$ ?v0 ?v1)) ?v1) :pattern ((pair$ ?v0 ?v1)))) :named a11))
(assert (! (forall ((?v0 Real_set$) (?v1 Real_real_set_prod$)) (= (= ?v0 (snd$ ?v1)) (exists ((?v2 Real)) (= ?v1 (pair$ ?v2 ?v0))))) :named a12))
(assert (! (forall ((?v0 Real_real_set_prod$)) (exists ((?v1 Real) (?v2 Real_set$)) (= ?v0 (pair$ ?v1 ?v2)))) :named a13))
(assert (! (forall ((?v0 Real_real_set_prod_bool_fun$) (?v1 Real_real_set_prod$)) (=> (forall ((?v2 Real) (?v3 Real_set$)) (fun_app$a ?v0 (pair$ ?v2 ?v3))) (fun_app$a ?v0 ?v1))) :named a14))
(assert (! (forall ((?v0 Real) (?v1 Real_set$) (?v2 Real) (?v3 Real_set$)) (=> (and (= (pair$ ?v0 ?v1) (pair$ ?v2 ?v3)) (=> (and (= ?v0 ?v2) (= ?v1 ?v3)) false)) false)) :named a15))
(check-sat)
;;;;(get-proof)
