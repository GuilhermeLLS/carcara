; --index-fresh-sorts --proof-version=2 --proof-prune --proof-merge --disable-print-success --disable-banner --max-time=29
(set-option :produce-proofs true)
(set-logic AUFLIRA)
(declare-sort Real_set$ 0)
(declare-sort Real_bool_fun$ 0)
(declare-sort Real_real_set_fun$ 0)
(declare-sort Real_set_bool_fun$ 0)
(declare-sort Real_real_set_prod$ 0)
(declare-sort Real_real_set_prod_set$ 0)
(declare-sort Real_real_set_bool_fun_fun$ 0)
(declare-sort Real_set_real_bool_fun_fun$ 0)
(declare-sort Real_real_set_prod_real_fun$ 0)
(declare-sort Real_real_set_real_bool_fun_fun_fun$ 0)
(declare-fun p$ () Real_real_set_prod_set$)
(declare-fun s$ () Real_set$)
(declare-fun uu$ (Real_real_set_prod_real_fun$) Real_real_set_bool_fun_fun$)
(declare-fun uua$ () Real_real_set_real_bool_fun_fun_fun$)
(declare-fun uub$ () Real_real_set_bool_fun_fun$)
(declare-fun uuc$ (Bool Real_real_set_bool_fun_fun$) Real_real_set_bool_fun_fun$)
(declare-fun fine$ (Real_real_set_fun$ Real_real_set_prod_set$) Bool)
(declare-fun pair$ (Real Real_set$) Real_real_set_prod$)
(declare-fun gamma$ () Real_real_set_fun$)
(declare-fun finite$ (Real_set$) Bool)
(declare-fun member$ () Real_real_set_bool_fun_fun$)
(declare-fun thesis$ () Bool)
(declare-fun fun_app$ (Real_set_bool_fun$ Real_set$) Bool)
(declare-fun member$a (Real_real_set_prod$ Real_real_set_prod_set$) Bool)
(declare-fun fun_app$a (Real_real_set_bool_fun_fun$ Real) Real_set_bool_fun$)
(declare-fun fun_app$b (Real_bool_fun$ Real) Bool)
(declare-fun fun_app$c (Real_set_real_bool_fun_fun$ Real_set$) Real_bool_fun$)
(declare-fun fun_app$d (Real_real_set_real_bool_fun_fun_fun$ Real) Real_set_real_bool_fun_fun$)
(declare-fun fun_app$e (Real_real_set_prod_real_fun$ Real_real_set_prod$) Real)
(declare-fun interior$ (Real_set$) Real_set$)
(declare-fun case_prod$ (Real_real_set_bool_fun_fun$ Real_real_set_prod$) Bool)
(declare-fun case_prod$a (Real_real_set_real_bool_fun_fun_fun$ Real_real_set_prod$) Real_bool_fun$)
(assert (! (forall ((?v0 Real) (?v1 Real_set$)) (! (= (fun_app$ (fun_app$a uub$ ?v0) ?v1) (exists ((?v2 Real)) (and (not (fun_app$ (fun_app$a member$ ?v2) s$)) (fun_app$ (fun_app$a member$ ?v2) (interior$ ?v1))))) :pattern ((fun_app$ (fun_app$a uub$ ?v0) ?v1)))) :named a0))
(assert (! (forall ((?v0 Real) (?v1 Real_set$) (?v2 Real)) (! (= (fun_app$b (fun_app$c (fun_app$d uua$ ?v0) ?v1) ?v2) (=> (member$a (pair$ ?v0 ?v1) p$) (and (not (fun_app$ (fun_app$a member$ ?v2) s$)) (fun_app$ (fun_app$a member$ ?v2) (interior$ ?v1))))) :pattern ((fun_app$b (fun_app$c (fun_app$d uua$ ?v0) ?v1) ?v2)))) :named a1))
(assert (! (forall ((?v0 Real_real_set_prod_real_fun$) (?v1 Real) (?v2 Real_set$)) (! (= (fun_app$ (fun_app$a (uu$ ?v0) ?v1) ?v2) (and (not (fun_app$ (fun_app$a member$ (fun_app$e ?v0 (pair$ ?v1 ?v2))) s$)) (fun_app$ (fun_app$a member$ (fun_app$e ?v0 (pair$ ?v1 ?v2))) (interior$ ?v2)))) :pattern ((fun_app$ (fun_app$a (uu$ ?v0) ?v1) ?v2)))) :named a2))
(assert (! (forall ((?v0 Bool) (?v1 Real_real_set_bool_fun_fun$) (?v2 Real) (?v3 Real_set$)) (! (= (fun_app$ (fun_app$a (uuc$ ?v0 ?v1) ?v2) ?v3) (and ?v0 (fun_app$ (fun_app$a ?v1 ?v2) ?v3))) :pattern ((fun_app$ (fun_app$a (uuc$ ?v0 ?v1) ?v2) ?v3)))) :named a3))
(assert (! (not thesis$) :named a4))
(assert (! (forall ((?v0 Real_real_set_prod_real_fun$)) (=> (forall ((?v1 Real_real_set_prod$)) (=> (member$a ?v1 p$) (case_prod$ (uu$ ?v0) ?v1))) thesis$)) :named a5))
(assert (! (= (forall ((?v0 Real_real_set_prod$)) (exists ((?v1 Real)) (fun_app$b (case_prod$a uua$ ?v0) ?v1))) (exists ((?v0 Real_real_set_prod_real_fun$)) (forall ((?v1 Real_real_set_prod$)) (fun_app$b (case_prod$a uua$ ?v1) (fun_app$e ?v0 ?v1))))) :named a6))
(assert (! (forall ((?v0 Real_real_set_prod$)) (=> (member$a ?v0 p$) (case_prod$ uub$ ?v0))) :named a7))
(assert (! (finite$ s$) :named a8))
(assert (! (forall ((?v0 Real_real_set_bool_fun_fun$) (?v1 Real) (?v2 Real_set$)) (=> (fun_app$ (fun_app$a ?v0 ?v1) ?v2) (case_prod$ ?v0 (pair$ ?v1 ?v2)))) :named a9))
(assert (! (forall ((?v0 Real_real_set_prod$) (?v1 Real_real_set_bool_fun_fun$)) (=> (forall ((?v2 Real) (?v3 Real_set$)) (=> (= ?v0 (pair$ ?v2 ?v3)) (fun_app$ (fun_app$a ?v1 ?v2) ?v3))) (case_prod$ ?v1 ?v0))) :named a10))
(assert (! (forall ((?v0 Real_real_set_bool_fun_fun$) (?v1 Real) (?v2 Real_set$)) (! (= (case_prod$ ?v0 (pair$ ?v1 ?v2)) (fun_app$ (fun_app$a ?v0 ?v1) ?v2)) :pattern ((case_prod$ ?v0 (pair$ ?v1 ?v2))))) :named a11))
(assert (! (forall ((?v0 Real_real_set_real_bool_fun_fun_fun$) (?v1 Real) (?v2 Real_set$)) (! (= (case_prod$a ?v0 (pair$ ?v1 ?v2)) (fun_app$c (fun_app$d ?v0 ?v1) ?v2)) :pattern ((case_prod$a ?v0 (pair$ ?v1 ?v2))))) :named a12))
(assert (! (fine$ gamma$ p$) :named a13))
(assert (! (forall ((?v0 Bool) (?v1 Real_real_set_bool_fun_fun$) (?v2 Real_real_set_prod$)) (= (case_prod$ (uuc$ ?v0 ?v1) ?v2) (and ?v0 (case_prod$ ?v1 ?v2)))) :named a14))
(assert (! (forall ((?v0 Real_set$)) (= (interior$ (interior$ ?v0)) (interior$ ?v0))) :named a15))
(assert (! (forall ((?v0 Real) (?v1 Real_set$) (?v2 Real) (?v3 Real_set$)) (= (= (pair$ ?v0 ?v1) (pair$ ?v2 ?v3)) (and (= ?v0 ?v2) (= ?v1 ?v3)))) :named a16))
(assert (! (forall ((?v0 Real) (?v1 Real_set$) (?v2 Real) (?v3 Real_set$)) (= (= (pair$ ?v0 ?v1) (pair$ ?v2 ?v3)) (and (= ?v0 ?v2) (= ?v1 ?v3)))) :named a17))
(assert (! (forall ((?v0 Real_real_set_bool_fun_fun$) (?v1 Real) (?v2 Real_set$)) (=> (case_prod$ ?v0 (pair$ ?v1 ?v2)) (fun_app$ (fun_app$a ?v0 ?v1) ?v2))) :named a18))
(assert (! (forall ((?v0 Real_real_set_bool_fun_fun$) (?v1 Real_real_set_prod$)) (=> (and (case_prod$ ?v0 ?v1) (forall ((?v2 Real) (?v3 Real_set$)) (=> (and (= ?v1 (pair$ ?v2 ?v3)) (fun_app$ (fun_app$a ?v0 ?v2) ?v3)) false))) false)) :named a19))
(check-sat)
;;;;(get-proof)
