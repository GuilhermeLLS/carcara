; --full-saturate-quant --inst-when=full-last-call --inst-no-entail --term-db-mode=relevant --multi-trigger-linear --no-statistics --random-seed=1 --lang=smt2 --continued-execution --tlimit 30000
(set-option :produce-unsat-cores true)
(set-logic AUFLIA)
(declare-sort A$ 0)
(declare-sort Nat$ 0)
(declare-sort A_fds$ 0)
(declare-sort Nat_a_fun$ 0)
(declare-sort A_bool_fun$ 0)
(declare-fun f$ () A_fds$)
(declare-fun m$ () Nat$)
(declare-fun s$ () A$)
(declare-fun uu$ () Nat_a_fun$)
(declare-fun suc$ (Nat$) Nat$)
(declare-fun the$ (A_bool_fun$) A$)
(declare-fun uua$ () A_bool_fun$)
(declare-fun plus$ (Nat$ Nat$) Nat$)
(declare-fun divide$ (A$ A$) A$)
(declare-fun suminf$ (Nat_a_fun$) A$)
(declare-fun fds_nth$ (A_fds$ Nat$) A$)
(declare-fun fun_app$ (Nat_a_fun$ Nat$) A$)
(declare-fun eval_fds$ (A_fds$ A$) A$)
(declare-fun fun_app$a (A_bool_fun$ A$) Bool)
(declare-fun nat_power$ (Nat$ A$) A$)
(declare-fun fds_remainder$ (Nat$ A_fds$) A_fds$)
(assert (! (forall ((?v0 Nat$)) (! (= (fun_app$ uu$ ?v0) (divide$ (fds_nth$ f$ (plus$ ?v0 (suc$ m$))) (nat_power$ (plus$ ?v0 (suc$ m$)) s$))) :pattern ((fun_app$ uu$ ?v0)))) :named a0))
(assert (! (forall ((?v0 A$)) (! (= (fun_app$a uua$ ?v0) false) :pattern ((fun_app$a uua$ ?v0)))) :named a1))
(assert (! (not (= (eval_fds$ (fds_remainder$ m$ f$) s$) (suminf$ uu$))) :named a2))
(assert (! (= (eval_fds$ (fds_remainder$ m$ f$) s$) (the$ uua$)) :named a3))
(assert (! (= (suminf$ uu$) (the$ uua$)) :named a4))
(check-sat)
(get-unsat-core)
