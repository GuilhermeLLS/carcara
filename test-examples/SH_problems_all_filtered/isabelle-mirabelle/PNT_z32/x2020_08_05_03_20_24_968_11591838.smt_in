; --proof-with-sharing --index-fresh-sorts --proof-define-skolems --proof-prune --proof-merge --disable-print-success --disable-banner --max-time=20
(set-option :produce-proofs true)
(set-logic AUFLIRA)
(declare-sort A$ 0)
(declare-sort Nat$ 0)
(declare-sort Nat_a_fun$ 0)
(declare-sort Nat_real_fun$ 0)
(declare-fun f$ () Nat_a_fun$)
(declare-fun g$ () Nat_real_fun$)
(declare-fun uu$ () Nat_real_fun$)
(declare-fun norm$ (A$) Real)
(declare-fun norm$a (Real) Real)
(declare-fun fun_app$ (Nat_real_fun$ Nat$) Real)
(declare-fun less_eq$ (Nat$ Nat$) Bool)
(declare-fun fun_app$a (Nat_a_fun$ Nat$) A$)
(declare-fun summable$ (Nat_real_fun$) Bool)
(declare-fun summable$a (Nat_a_fun$) Bool)
(assert (! (forall ((?v0 Nat$)) (! (= (fun_app$ uu$ ?v0) (norm$ (fun_app$a f$ ?v0))) :pattern ((fun_app$ uu$ ?v0)))) :named a0))
(assert (! (forall ((?v0 Nat$)) (<= (norm$ (fun_app$a f$ ?v0)) (fun_app$ g$ ?v0))) :named a1))
(assert (! (summable$ g$) :named a2))
(assert (! (forall ((?v0 A$)) (<= 0.0 (norm$ ?v0))) :named a3))
(assert (! (forall ((?v0 Real)) (<= 0.0 (norm$a ?v0))) :named a4))
(assert (! (forall ((?v0 Real)) (= (norm$a ?v0) (ite (< ?v0 0.0) (- ?v0) ?v0))) :named a5))
(assert (! (forall ((?v0 Nat_a_fun$) (?v1 Nat_real_fun$)) (=> (and (exists ((?v2 Nat$)) (forall ((?v3 Nat$)) (=> (less_eq$ ?v2 ?v3) (<= (norm$ (fun_app$a ?v0 ?v3)) (fun_app$ ?v1 ?v3))))) (summable$ ?v1)) (summable$a ?v0))) :named a6))
(assert (! (forall ((?v0 Nat_real_fun$) (?v1 Nat_real_fun$)) (=> (and (exists ((?v2 Nat$)) (forall ((?v3 Nat$)) (=> (less_eq$ ?v2 ?v3) (<= (norm$a (fun_app$ ?v0 ?v3)) (fun_app$ ?v1 ?v3))))) (summable$ ?v1)) (summable$ ?v0))) :named a7))
(assert (! (not (summable$ uu$)) :named a8))
(check-sat)
;;;;(get-proof)
