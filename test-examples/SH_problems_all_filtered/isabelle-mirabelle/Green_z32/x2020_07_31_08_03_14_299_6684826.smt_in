; smt.random_seed=1 smt.refine_inj_axioms=false -T:20 -smt2
(set-option :produce-proofs true)
(set-logic AUFLIA)
(declare-sort A$ 0)
(declare-sort B$ 0)
(declare-sort C$ 0)
(declare-sort A_set$ 0)
(declare-sort A_c_fun$ 0)
(declare-sort A_b_prod$ 0)
(declare-sort B_filter$ 0)
(declare-sort A_measure$ 0)
(declare-sort B_measure$ 0)
(declare-sort B_bool_fun$ 0)
(declare-fun f$ (A_b_prod$) C$)
(declare-fun uu$ (B$) A_c_fun$)
(declare-fun top$ () A_set$)
(declare-fun uua$ () B_bool_fun$)
(declare-fun pair$ (A$ B$) A_b_prod$)
(declare-fun v4_1$ (B_bool_fun$ B_bool_fun$ B_bool_fun$) B$)
(declare-fun lborel$ () A_measure$)
(declare-fun fun_app$ (B_bool_fun$ B$) Bool)
(declare-fun lborel$a () B_measure$)
(declare-fun fun_app$a (A_c_fun$ A$) C$)
(declare-fun integral$ (A_set$ A_c_fun$) C$)
(declare-fun ae_filter$ (B_measure$) B_filter$)
(declare-fun eventually$ (B_bool_fun$ B_filter$) Bool)
(declare-fun lebesgue_integral$ (A_measure$ A_c_fun$) C$)
(assert (! (forall ((?v0 B$)) (! (= (fun_app$ uua$ ?v0) (= (lebesgue_integral$ lborel$ (uu$ ?v0)) (integral$ top$ (uu$ ?v0)))) :pattern ((fun_app$ uua$ ?v0)))) :named a0))
(assert (! (forall ((?v0 B$) (?v1 A$)) (! (= (fun_app$a (uu$ ?v0) ?v1) (f$ (pair$ ?v1 ?v0))) :pattern ((fun_app$a (uu$ ?v0) ?v1)))) :named a1))
(assert (! (forall ((?v0 B_bool_fun$) (?v1 B_bool_fun$) (?v2 B_bool_fun$)) (= (exists ((?v3 B$)) (and (and (fun_app$ ?v2 ?v3) (fun_app$ ?v1 ?v3)) (not (fun_app$ ?v0 ?v3)))) (and (and (fun_app$ ?v2 (v4_1$ ?v0 ?v1 ?v2)) (fun_app$ ?v1 (v4_1$ ?v0 ?v1 ?v2))) (not (fun_app$ ?v0 (v4_1$ ?v0 ?v1 ?v2)))))) :named a2))
(assert (! (eventually$ uua$ (ae_filter$ lborel$a)) :named a3))
(assert (! (forall ((?v0 B_bool_fun$) (?v1 B_filter$) (?v2 B_bool_fun$) (?v3 B_bool_fun$)) (=> (and (eventually$ ?v0 ?v1) (and (eventually$ ?v2 ?v1) (forall ((?v4 B$)) (=> (and (fun_app$ ?v0 ?v4) (fun_app$ ?v2 ?v4)) (fun_app$ ?v3 ?v4))))) (eventually$ ?v3 ?v1))) :named a4))
(assert (! (not (eventually$ uua$ (ae_filter$ lborel$a))) :named a5))
(check-sat)
;;;;(get-proof)
