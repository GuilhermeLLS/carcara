; --proof-with-sharing --index-fresh-sorts --proof-define-skolems --proof-prune --proof-merge --disable-print-success --disable-banner --max-time=3
(set-option :produce-proofs true)
(set-logic AUFLIA)
(declare-sort A$ 0)
(declare-sort A_set$ 0)
(declare-sort A_quot$ 0)
(declare-sort A_set_set$ 0)
(declare-sort A_bool_fun$ 0)
(declare-sort A_set_set_set$ 0)
(declare-sort A_set_bool_fun$ 0)
(declare-sort A_quot_bool_fun$ 0)
(declare-sort A_a_bool_fun_fun$ 0)
(declare-sort A_quot_a_set_fun$ 0)
(declare-sort A_set_a_quot_fun$ 0)
(declare-sort A_set_set_bool_fun$ 0)
(declare-sort A_set_a_set_bool_fun_fun$ 0)
(declare-fun a$ () A_quot$)
(declare-fun uu$ () A_set_bool_fun$)
(declare-fun eqv$ () A_a_bool_fun_fun$)
(declare-fun uua$ (A_set_a_set_bool_fun_fun$) A_set_set_bool_fun$)
(declare-fun uub$ (A_a_bool_fun_fun$) A_set_bool_fun$)
(declare-fun quot$ () A_set_set$)
(declare-fun class$ (A$) A_quot$)
(declare-fun quot$a (A_set_a_set_bool_fun_fun$) A_set_set_set$)
(declare-fun quot$b (A_a_bool_fun_fun$) A_set_set$)
(declare-fun member$ (A_set$ A_set_set$) Bool)
(declare-fun thesis$ () Bool)
(declare-fun collect$ (A_bool_fun$) A_set$)
(declare-fun fun_app$ (A_set_bool_fun$ A_set$) Bool)
(declare-fun less_eq$ (A_set_set$ A_set_set$) Bool)
(declare-fun member$a (A$) A_set_bool_fun$)
(declare-fun abs_quot$ () A_set_a_quot_fun$)
(declare-fun collect$a (A_set_bool_fun$) A_set_set$)
(declare-fun collect$b (A_set_set_bool_fun$) A_set_set_set$)
(declare-fun fun_app$a (A_a_bool_fun_fun$ A$) A_bool_fun$)
(declare-fun fun_app$b (A_set_set_bool_fun$ A_set_set$) Bool)
(declare-fun fun_app$c (A_set_a_set_bool_fun_fun$ A_set$) A_set_bool_fun$)
(declare-fun fun_app$d (A_bool_fun$ A$) Bool)
(declare-fun fun_app$e (A_set_a_quot_fun$ A_set$) A_quot$)
(declare-fun fun_app$f (A_quot_a_set_fun$ A_quot$) A_set$)
(declare-fun fun_app$g (A_quot_bool_fun$ A_quot$) Bool)
(declare-fun less_eq$a () A_set_a_set_bool_fun_fun$)
(declare-fun rep_quot$ () A_quot_a_set_fun$)
(declare-fun type_definition$ (A_quot_a_set_fun$ A_set_a_quot_fun$ A_set_set$) Bool)
(assert (! (forall ((?v0 A_set$)) (! (= (fun_app$ uu$ ?v0) (exists ((?v1 A$)) (and (= ?v0 (collect$ (fun_app$a eqv$ ?v1))) true))) :pattern ((fun_app$ uu$ ?v0)))) :named a0))
(assert (! (forall ((?v0 A_set_a_set_bool_fun_fun$) (?v1 A_set_set$)) (! (= (fun_app$b (uua$ ?v0) ?v1) (exists ((?v2 A_set$)) (and (= ?v1 (collect$a (fun_app$c ?v0 ?v2))) true))) :pattern ((fun_app$b (uua$ ?v0) ?v1)))) :named a1))
(assert (! (forall ((?v0 A_a_bool_fun_fun$) (?v1 A_set$)) (! (= (fun_app$ (uub$ ?v0) ?v1) (exists ((?v2 A$)) (and (= ?v1 (collect$ (fun_app$a ?v0 ?v2))) true))) :pattern ((fun_app$ (uub$ ?v0) ?v1)))) :named a2))
(assert (! (not thesis$) :named a3))
(assert (! (forall ((?v0 A$)) (=> (= a$ (class$ ?v0)) thesis$)) :named a4))
(assert (! (forall ((?v0 A$) (?v1 A$)) (=> (fun_app$d (fun_app$a eqv$ ?v0) ?v1) (fun_app$d (fun_app$a eqv$ ?v1) ?v0))) :named a5))
(assert (! (forall ((?v0 A$)) (=> (= a$ (class$ ?v0)) thesis$)) :named a6))
(assert (! (forall ((?v0 A_set$)) (=> (and (member$ ?v0 quot$) (forall ((?v1 A$)) (=> (= ?v0 (collect$ (fun_app$a eqv$ ?v1))) false))) false)) :named a7))
(assert (! (forall ((?v0 A$)) (! (= (class$ ?v0) (fun_app$e abs_quot$ (collect$ (fun_app$a eqv$ ?v0)))) :pattern ((class$ ?v0)))) :named a8))
(assert (! (forall ((?v0 A_quot$)) (exists ((?v1 A$)) (= ?v0 (class$ ?v1)))) :named a9))
(assert (! (forall ((?v0 A_set$) (?v1 A_set_bool_fun$)) (= (member$ ?v0 (collect$a ?v1)) (fun_app$ ?v1 ?v0))) :named a10))
(assert (! (forall ((?v0 A$) (?v1 A_bool_fun$)) (= (fun_app$ (member$a ?v0) (collect$ ?v1)) (fun_app$d ?v1 ?v0))) :named a11))
(assert (! (forall ((?v0 A_quot$)) (=> (forall ((?v1 A_set$)) (=> (and (= ?v0 (fun_app$e abs_quot$ ?v1)) (member$ ?v1 quot$)) false)) false)) :named a12))
(assert (! (= quot$ (collect$a uu$)) :named a13))
(assert (! (forall ((?v0 A$) (?v1 A$) (?v2 A$)) (=> (and (fun_app$d (fun_app$a eqv$ ?v0) ?v1) (fun_app$d (fun_app$a eqv$ ?v1) ?v2)) (fun_app$d (fun_app$a eqv$ ?v0) ?v2))) :named a14))
(assert (! (forall ((?v0 A_set_set$) (?v1 A_set_set$)) (=> (forall ((?v2 A_set$)) (=> (member$ ?v2 ?v0) (member$ ?v2 ?v1))) (less_eq$ ?v0 ?v1))) :named a15))
(assert (! (forall ((?v0 A_set$) (?v1 A_set$)) (=> (forall ((?v2 A$)) (=> (fun_app$ (member$a ?v2) ?v0) (fun_app$ (member$a ?v2) ?v1))) (fun_app$ (fun_app$c less_eq$a ?v0) ?v1))) :named a16))
(assert (! (forall ((?v0 A$) (?v1 A$)) (=> (not (fun_app$d (fun_app$a eqv$ ?v0) ?v1)) (not (fun_app$d (fun_app$a eqv$ ?v1) ?v0)))) :named a17))
(assert (! (forall ((?v0 A$) (?v1 A$) (?v2 A$)) (=> (and (not (fun_app$d (fun_app$a eqv$ ?v0) ?v1)) (fun_app$d (fun_app$a eqv$ ?v1) ?v2)) (not (fun_app$d (fun_app$a eqv$ ?v0) ?v2)))) :named a18))
(assert (! (forall ((?v0 A$)) (fun_app$d (fun_app$a eqv$ ?v0) ?v0)) :named a19))
(assert (! (forall ((?v0 A$) (?v1 A$) (?v2 A$)) (=> (and (fun_app$d (fun_app$a eqv$ ?v0) ?v1) (not (fun_app$d (fun_app$a eqv$ ?v1) ?v2))) (not (fun_app$d (fun_app$a eqv$ ?v0) ?v2)))) :named a20))
(assert (! (type_definition$ rep_quot$ abs_quot$ quot$) :named a21))
(assert (! (forall ((?v0 A_set$) (?v1 A_set_bool_fun$)) (=> (and (member$ ?v0 quot$) (forall ((?v2 A_quot$)) (fun_app$ ?v1 (fun_app$f rep_quot$ ?v2)))) (fun_app$ ?v1 ?v0))) :named a22))
(assert (! (forall ((?v0 A_set$) (?v1 A_set_bool_fun$)) (=> (member$ ?v0 (collect$a ?v1)) (fun_app$ ?v1 ?v0))) :named a23))
(assert (! (forall ((?v0 A$) (?v1 A_bool_fun$)) (=> (fun_app$ (member$a ?v0) (collect$ ?v1)) (fun_app$d ?v1 ?v0))) :named a24))
(assert (! (forall ((?v0 A_set$)) (=> (and (member$ ?v0 quot$) (forall ((?v1 A_quot$)) (=> (= ?v0 (fun_app$f rep_quot$ ?v1)) false))) false)) :named a25))
(assert (! (forall ((?v0 A_set$)) (=> (member$ ?v0 quot$) (= (fun_app$f rep_quot$ (fun_app$e abs_quot$ ?v0)) ?v0))) :named a26))
(assert (! (forall ((?v0 A_set$) (?v1 A_set$)) (=> (and (member$ ?v0 quot$) (member$ ?v1 quot$)) (= (= (fun_app$e abs_quot$ ?v0) (fun_app$e abs_quot$ ?v1)) (= ?v0 ?v1)))) :named a27))
(assert (! (forall ((?v0 A_quot$)) (= (fun_app$e abs_quot$ (fun_app$f rep_quot$ ?v0)) ?v0)) :named a28))
(assert (! (forall ((?v0 A_quot_bool_fun$) (?v1 A_quot$)) (=> (forall ((?v2 A_set$)) (=> (member$ ?v2 quot$) (fun_app$g ?v0 (fun_app$e abs_quot$ ?v2)))) (fun_app$g ?v0 ?v1))) :named a29))
(assert (! (forall ((?v0 A_quot$)) (member$ (fun_app$f rep_quot$ ?v0) quot$)) :named a30))
(assert (! (forall ((?v0 A_quot$) (?v1 A_quot$)) (= (= (fun_app$f rep_quot$ ?v0) (fun_app$f rep_quot$ ?v1)) (= ?v0 ?v1))) :named a31))
(assert (! (forall ((?v0 A$)) (member$ (collect$ (fun_app$a eqv$ ?v0)) quot$)) :named a32))
(assert (! (forall ((?v0 A_set_a_set_bool_fun_fun$)) (= (quot$a ?v0) (collect$b (uua$ ?v0)))) :named a33))
(assert (! (forall ((?v0 A_a_bool_fun_fun$)) (= (quot$b ?v0) (collect$a (uub$ ?v0)))) :named a34))
(assert (! (forall ((?v0 A_a_bool_fun_fun$)) (! (= (quot$b ?v0) (quot$b ?v0)) :pattern ((quot$b ?v0)))) :named a35))
(check-sat)
;;;;;;(get-proof)
