; --proof-with-sharing --index-fresh-sorts --proof-define-skolems --proof-prune --proof-merge --disable-print-success --disable-banner --max-time=30
(set-option :produce-proofs true)
(set-logic AUFLIA)
(declare-sort A_set$ 0)
(declare-sort Nat_set$ 0)
(declare-sort A_nat_fun$ 0)
(declare-sort Nat_a_fun$ 0)
(declare-fun s$ () A_set$)
(declare-fun image$ (A_nat_fun$ A_set$) Nat_set$)
(declare-fun image$a (Nat_a_fun$ Nat_set$) A_set$)
(declare-fun inj_on$ (A_nat_fun$ A_set$) Bool)
(declare-fun thesis$ () Bool)
(declare-fun inj_on$a (Nat_a_fun$ Nat_set$) Bool)
(declare-fun bij_betw$ (Nat_a_fun$ Nat_set$ A_set$) Bool)
(declare-fun bij_betw$a (A_nat_fun$ A_set$ Nat_set$) Bool)
(declare-fun countable$ (A_set$) Bool)
(assert (! (not thesis$) :named a0))
(assert (! (forall ((?v0 Nat_a_fun$) (?v1 Nat_set$)) (=> (bij_betw$ ?v0 ?v1 s$) thesis$)) :named a1))
(assert (! (countable$ s$) :named a2))
(assert (! (forall ((?v0 A_nat_fun$) (?v1 A_set$) (?v2 Nat_set$)) (! (= (bij_betw$a ?v0 ?v1 ?v2) (and (inj_on$ ?v0 ?v1) (= (image$ ?v0 ?v1) ?v2))) :pattern ((bij_betw$a ?v0 ?v1 ?v2)))) :named a3))
(assert (! (forall ((?v0 Nat_a_fun$) (?v1 Nat_set$) (?v2 A_set$)) (! (= (bij_betw$ ?v0 ?v1 ?v2) (and (inj_on$a ?v0 ?v1) (= (image$a ?v0 ?v1) ?v2))) :pattern ((bij_betw$ ?v0 ?v1 ?v2)))) :named a4))
(assert (! (forall ((?v0 Nat_a_fun$) (?v1 Nat_set$)) (=> (bij_betw$ ?v0 ?v1 s$) thesis$)) :named a5))
(assert (! (forall ((?v0 A_nat_fun$) (?v1 A_set$) (?v2 Nat_set$)) (=> (bij_betw$a ?v0 ?v1 ?v2) (exists ((?v3 Nat_a_fun$)) (bij_betw$ ?v3 ?v2 ?v1)))) :named a6))
(assert (! (forall ((?v0 Nat_a_fun$) (?v1 Nat_set$) (?v2 A_set$)) (=> (bij_betw$ ?v0 ?v1 ?v2) (exists ((?v3 A_nat_fun$)) (bij_betw$a ?v3 ?v2 ?v1)))) :named a7))
(assert (! (forall ((?v0 A_set$)) (=> (and (countable$ ?v0) (forall ((?v1 A_nat_fun$)) (=> (inj_on$ ?v1 ?v0) false))) false)) :named a8))
(check-sat)
;;;;;;(get-proof)
