; --proof-with-sharing --index-fresh-sorts --proof-define-skolems --proof-prune --proof-merge --disable-print-success --disable-banner --max-time=30
(set-option :produce-proofs true)
(set-logic AUFLIA)
(declare-sort A$ 0)
(declare-sort Nat$ 0)
(declare-sort Nat_a_fun$ 0)
(declare-sort Nat_a_fun_set$ 0)
(declare-fun f$ (Nat$) A$)
(declare-fun g$ (Nat$) A$)
(declare-fun h$ (Nat$) A$)
(declare-fun uu$ () Nat_a_fun$)
(declare-fun one$ () Nat$)
(declare-fun uua$ () Nat_a_fun$)
(declare-fun uub$ () Nat_a_fun$)
(declare-fun bigo$ (Nat_a_fun$) Nat_a_fun_set$)
(declare-fun plus$ (Nat$ Nat$) Nat$)
(declare-fun zero$ () Nat$)
(declare-fun member$ (Nat_a_fun$ Nat_a_fun_set$) Bool)
(declare-fun fun_app$ (Nat_a_fun$ Nat$) A$)
(declare-fun elt_set_plus$ (Nat_a_fun$ Nat_a_fun_set$) Nat_a_fun_set$)
(assert (! (forall ((?v0 Nat$)) (! (= (fun_app$ uub$ ?v0) (h$ (plus$ ?v0 one$))) :pattern ((fun_app$ uub$ ?v0)))) :named a0))
(assert (! (forall ((?v0 Nat$)) (! (= (fun_app$ uua$ ?v0) (g$ (plus$ ?v0 one$))) :pattern ((fun_app$ uua$ ?v0)))) :named a1))
(assert (! (forall ((?v0 Nat$)) (! (= (fun_app$ uu$ ?v0) (f$ (plus$ ?v0 one$))) :pattern ((fun_app$ uu$ ?v0)))) :named a2))
(assert (! (not (member$ uu$ (elt_set_plus$ uua$ (bigo$ uub$)))) :named a3))
(assert (! (member$ uu$ (elt_set_plus$ uua$ (bigo$ uub$))) :named a4))
(assert (! (= (f$ zero$) (g$ zero$)) :named a5))
(check-sat)
;;;;;;(get-proof)
