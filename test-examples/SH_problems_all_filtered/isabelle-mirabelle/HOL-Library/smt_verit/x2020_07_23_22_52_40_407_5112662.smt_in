; --proof-with-sharing --index-fresh-sorts --proof-define-skolems --proof-prune --proof-merge --disable-print-success --disable-banner --max-time=30
(set-option :produce-proofs true)
(set-logic AUFLIA)
(declare-sort A$ 0)
(declare-sort B$ 0)
(declare-sort Nat$ 0)
(declare-sort A_set$ 0)
(declare-sort B_set$ 0)
(declare-sort A_list$ 0)
(declare-sort B_list$ 0)
(declare-sort A_option$ 0)
(declare-sort B_option$ 0)
(declare-sort A_a_prod_list$ 0)
(declare-sort A_b_prod_list$ 0)
(declare-sort B_a_prod_list$ 0)
(declare-sort B_b_prod_list$ 0)
(declare-fun x$ () A$)
(declare-fun as$ () A_list$)
(declare-fun bs$ () B_list$)
(declare-fun xs$ () B_list$)
(declare-fun set$ (A_list$) A_set$)
(declare-fun the$ (A_option$) A$)
(declare-fun top$ () A_set$)
(declare-fun zip$ (A_list$ B_list$) A_b_prod_list$)
(declare-fun none$ () B_option$)
(declare-fun set$a (B_list$) B_set$)
(declare-fun size$ (B_list$) Nat$)
(declare-fun some$ (B$) B_option$)
(declare-fun the$a (B_option$) B$)
(declare-fun top$a () B_set$)
(declare-fun zip$a (B_list$ B_list$) B_b_prod_list$)
(declare-fun zip$b (B_list$ A_list$) B_a_prod_list$)
(declare-fun zip$c (A_list$ A_list$) A_a_prod_list$)
(declare-fun none$a () A_option$)
(declare-fun size$a (A_list$) Nat$)
(declare-fun some$a (A$) A_option$)
(declare-fun map_of$ (A_b_prod_list$ A$) B_option$)
(declare-fun member$ (A$ A_set$) Bool)
(declare-fun map_of$a (B_b_prod_list$ B$) B_option$)
(declare-fun map_of$b (B_a_prod_list$ B$) A_option$)
(declare-fun map_of$c (A_a_prod_list$ A$) A_option$)
(declare-fun member$a (B$ B_set$) Bool)
(assert (! (not (exists ((?v0 B$)) (= (map_of$ (zip$ as$ xs$) x$) (some$ ?v0)))) :named a0))
(assert (! (= (set$ as$) top$) :named a1))
(assert (! (= (set$a bs$) top$a) :named a2))
(assert (! (= (size$ xs$) (size$a as$)) :named a3))
(assert (! (forall ((?v0 A$)) (= (member$ ?v0 top$) true)) :named a4))
(assert (! (forall ((?v0 B$)) (= (member$a ?v0 top$a) true)) :named a5))
(assert (! (forall ((?v0 B_list$) (?v1 B_list$) (?v2 B$)) (=> (= (size$ ?v0) (size$ ?v1)) (= (= (map_of$a (zip$a ?v0 ?v1) ?v2) none$) (not (member$a ?v2 (set$a ?v0)))))) :named a6))
(assert (! (forall ((?v0 B_list$) (?v1 A_list$) (?v2 B$)) (=> (= (size$ ?v0) (size$a ?v1)) (= (= (map_of$b (zip$b ?v0 ?v1) ?v2) none$a) (not (member$a ?v2 (set$a ?v0)))))) :named a7))
(assert (! (forall ((?v0 A_list$) (?v1 B_list$) (?v2 A$)) (=> (= (size$a ?v0) (size$ ?v1)) (= (= (map_of$ (zip$ ?v0 ?v1) ?v2) none$) (not (member$ ?v2 (set$ ?v0)))))) :named a8))
(assert (! (forall ((?v0 A_list$) (?v1 A_list$) (?v2 A$)) (=> (= (size$a ?v0) (size$a ?v1)) (= (= (map_of$c (zip$c ?v0 ?v1) ?v2) none$a) (not (member$ ?v2 (set$ ?v0)))))) :named a9))
(assert (! (forall ((?v0 A_option$)) (=> (not (= ?v0 none$a)) (= (some$a (the$ ?v0)) ?v0))) :named a10))
(assert (! (forall ((?v0 B_option$)) (=> (not (= ?v0 none$)) (= (some$ (the$a ?v0)) ?v0))) :named a11))
(check-sat)
;;;;;;(get-proof)
