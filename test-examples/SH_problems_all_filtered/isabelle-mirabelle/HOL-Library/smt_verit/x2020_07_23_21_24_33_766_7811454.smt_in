; --proof-with-sharing --index-fresh-sorts --proof-define-skolems --proof-prune --proof-merge --disable-print-success --disable-banner --max-time=30
(set-option :produce-proofs true)
(set-logic AUFLIA)
(declare-sort A$ 0)
(declare-sort A_set$ 0)
(declare-sort B_option$ 0)
(declare-sort A_b_prod_list$ 0)
(declare-sort A_b_option_fun$ 0)
(declare-fun ma$ () A_b_option_fun$)
(declare-fun uu$ () A_b_option_fun$)
(declare-fun bot$ () A_set$)
(declare-fun dom$ (A_b_option_fun$) A_set$)
(declare-fun nil$ () A_b_prod_list$)
(declare-fun none$ () B_option$)
(declare-fun map_of$ (A_b_prod_list$) A_b_option_fun$)
(declare-fun fun_app$ (A_b_option_fun$ A$) B_option$)
(assert (! (forall ((?v0 A$)) (! (= (fun_app$ uu$ ?v0) none$) :pattern ((fun_app$ uu$ ?v0)))) :named a0))
(assert (! (not (exists ((?v0 A_b_prod_list$)) (= (map_of$ ?v0) ma$))) :named a1))
(assert (! (forall ((?v0 A$)) (! (= (fun_app$ (map_of$ nil$) ?v0) none$) :pattern ((fun_app$ (map_of$ nil$) ?v0)))) :named a2))
(assert (! (forall ((?v0 A$)) (= (fun_app$ ma$ ?v0) none$)) :named a3))
(assert (! (forall ((?v0 A_b_option_fun$)) (= (= (dom$ ?v0) bot$) (= ?v0 uu$))) :named a4))
(assert (! (= bot$ (dom$ ma$)) :named a5))
(assert (! (forall ((?v0 A_b_prod_list$)) (= (= uu$ (map_of$ ?v0)) (= ?v0 nil$))) :named a6))
(check-sat)
;;;;;;(get-proof)
