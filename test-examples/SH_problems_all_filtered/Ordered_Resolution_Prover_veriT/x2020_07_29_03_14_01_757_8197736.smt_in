; --proof-with-sharing --index-fresh-sorts --proof-define-skolems --proof-prune --proof-merge --disable-print-success --disable-banner --max-time=30
(set-option :produce-proofs true)
(set-logic AUFLIA)
(declare-sort S$ 0)
(declare-sort A_s_a_fun_fun$ 0)
(declare-sort A_literal_multiset$ 0)
(declare-sort A_literal_multiset_set$ 0)
(declare-sort A_literal_multiset_bool_fun$ 0)
(declare-fun c$ () A_literal_multiset$)
(declare-fun m$ () A_literal_multiset_set$)
(declare-fun s$ (A_literal_multiset$) A_literal_multiset$)
(declare-fun uu$ () A_literal_multiset_bool_fun$)
(declare-fun eps$ (A_literal_multiset_bool_fun$) A_literal_multiset$)
(declare-fun member$ (A_literal_multiset$ A_literal_multiset_set$) Bool)
(declare-fun fun_app$ (A_literal_multiset_bool_fun$ A_literal_multiset$) Bool)
(declare-fun subst_atm$ () A_s_a_fun_fun$)
(declare-fun subst_cls$ (A_s_a_fun_fun$ A_literal_multiset$ S$) A_literal_multiset$)
(declare-fun is_ground_subst$ (A_s_a_fun_fun$ S$) Bool)
(declare-fun grounding_of_clss$ (A_s_a_fun_fun$ A_literal_multiset_set$) A_literal_multiset_set$)
(assert (! (forall ((?v0 A_literal_multiset$)) (! (= (fun_app$ uu$ ?v0) (exists ((?v1 A_literal_multiset$) (?v2 S$)) (and (member$ ?v1 m$) (and (= c$ (subst_cls$ subst_atm$ ?v1 ?v2)) (and (= ?v0 (subst_cls$ subst_atm$ (s$ ?v1) ?v2)) (is_ground_subst$ subst_atm$ ?v2)))))) :pattern ((fun_app$ uu$ ?v0)))) :named a0))
(assert (! (not (= (ite (member$ c$ (grounding_of_clss$ subst_atm$ m$)) (eps$ uu$) (s$ c$)) (s$ c$))) :named a1))
(assert (! (not (member$ c$ (grounding_of_clss$ subst_atm$ m$))) :named a2))
(check-sat)
;;;;(get-proof)
