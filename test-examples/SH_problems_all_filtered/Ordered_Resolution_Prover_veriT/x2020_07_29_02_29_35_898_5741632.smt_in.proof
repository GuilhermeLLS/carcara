(assume a0 (not (= e$ e$a)))
(assume a1 (= e$a (subst_cls$ subst_atm$ (plus$ (sum_mset$ (mset$ cs$)) da$) sigma$)))
(assume a2 (= e$ (subst_cls$ subst_atm$ (plus$ (sum_mset$ (mset$ cs$a)) dAa$) sigma$a)))
(assume a3 (= da$ dAa$))
(assume a4 (= cs$ cs$a))
(assume a5 (= sigma$ sigma$b))
(assume a6 (= sigma$a sigma$c))
(assume a7 (= sigma$b sigma$c))
(step t9 (cl (not (= e$ (subst_cls$ subst_atm$ (plus$ (sum_mset$ (mset$ cs$a)) dAa$) sigma$a))) (not (= (subst_cls$ subst_atm$ (plus$ (sum_mset$ (mset$ cs$)) da$) sigma$) (subst_cls$ subst_atm$ (plus$ (sum_mset$ (mset$ cs$a)) dAa$) sigma$a))) (not (= e$a (subst_cls$ subst_atm$ (plus$ (sum_mset$ (mset$ cs$)) da$) sigma$))) (= e$ e$a)) :rule eq_transitive)
(step t10 (cl (not (= subst_atm$ subst_atm$)) (not (= (plus$ (sum_mset$ (mset$ cs$)) da$) (plus$ (sum_mset$ (mset$ cs$a)) dAa$))) (not (= sigma$ sigma$a)) (= (subst_cls$ subst_atm$ (plus$ (sum_mset$ (mset$ cs$)) da$) sigma$) (subst_cls$ subst_atm$ (plus$ (sum_mset$ (mset$ cs$a)) dAa$) sigma$a))) :rule eq_congruent)
(step t11 (cl (= subst_atm$ subst_atm$)) :rule eq_reflexive)
(step t12 (cl (not (= (plus$ (sum_mset$ (mset$ cs$)) da$) (plus$ (sum_mset$ (mset$ cs$a)) dAa$))) (not (= sigma$ sigma$a)) (= (subst_cls$ subst_atm$ (plus$ (sum_mset$ (mset$ cs$)) da$) sigma$) (subst_cls$ subst_atm$ (plus$ (sum_mset$ (mset$ cs$a)) dAa$) sigma$a))) :rule th_resolution :premises (t10 t11))
(step t13 (cl (not (= (sum_mset$ (mset$ cs$)) (sum_mset$ (mset$ cs$a)))) (not (= da$ dAa$)) (= (plus$ (sum_mset$ (mset$ cs$)) da$) (plus$ (sum_mset$ (mset$ cs$a)) dAa$))) :rule eq_congruent)
(step t14 (cl (not (= (mset$ cs$) (mset$ cs$a))) (= (sum_mset$ (mset$ cs$)) (sum_mset$ (mset$ cs$a)))) :rule eq_congruent)
(step t15 (cl (not (= cs$ cs$a)) (= (mset$ cs$) (mset$ cs$a))) :rule eq_congruent)
(step t16 (cl (= (sum_mset$ (mset$ cs$)) (sum_mset$ (mset$ cs$a))) (not (= cs$ cs$a))) :rule th_resolution :premises (t14 t15))
(step t17 (cl (not (= da$ dAa$)) (= (plus$ (sum_mset$ (mset$ cs$)) da$) (plus$ (sum_mset$ (mset$ cs$a)) dAa$)) (not (= cs$ cs$a))) :rule th_resolution :premises (t13 t16))
(step t18 (cl (not (= sigma$ sigma$a)) (= (subst_cls$ subst_atm$ (plus$ (sum_mset$ (mset$ cs$)) da$) sigma$) (subst_cls$ subst_atm$ (plus$ (sum_mset$ (mset$ cs$a)) dAa$) sigma$a)) (not (= da$ dAa$)) (not (= cs$ cs$a))) :rule th_resolution :premises (t12 t17))
(step t19 (cl (not (= sigma$ sigma$b)) (not (= sigma$b sigma$c)) (not (= sigma$a sigma$c)) (= sigma$ sigma$a)) :rule eq_transitive)
(step t20 (cl (= (subst_cls$ subst_atm$ (plus$ (sum_mset$ (mset$ cs$)) da$) sigma$) (subst_cls$ subst_atm$ (plus$ (sum_mset$ (mset$ cs$a)) dAa$) sigma$a)) (not (= da$ dAa$)) (not (= cs$ cs$a)) (not (= sigma$ sigma$b)) (not (= sigma$b sigma$c)) (not (= sigma$a sigma$c))) :rule th_resolution :premises (t18 t19))
(step t21 (cl (not (= e$ (subst_cls$ subst_atm$ (plus$ (sum_mset$ (mset$ cs$a)) dAa$) sigma$a))) (not (= e$a (subst_cls$ subst_atm$ (plus$ (sum_mset$ (mset$ cs$)) da$) sigma$))) (= e$ e$a) (not (= da$ dAa$)) (not (= cs$ cs$a)) (not (= sigma$ sigma$b)) (not (= sigma$b sigma$c)) (not (= sigma$a sigma$c))) :rule th_resolution :premises (t9 t20))
(step t22 (cl) :rule resolution :premises (t21 a0 a1 a2 a3 a4 a5 a6 a7))
