; --proof-with-sharing --index-fresh-sorts --proof-define-skolems --proof-prune --proof-merge --disable-print-success --disable-banner --max-time=30
(set-option :produce-proofs true)
(set-logic AUFLIA)
(declare-sort A$ 0)
(declare-sort A_list$ 0)
(declare-sort A_llist$ 0)
(declare-sort A_list_bool_fun$ 0)
(declare-sort A_a_bool_fun_fun$ 0)
(declare-fun r$ () A_a_bool_fun_fun$)
(declare-fun x$ () A$)
(declare-fun y$ () A$)
(declare-fun uu$ () A_list_bool_fun$)
(declare-fun eps$ (A_list_bool_fun$) A_list$)
(declare-fun nil$ () A_list$)
(declare-fun cons$ (A$ A_list$) A_list$)
(declare-fun chain$ (A_a_bool_fun_fun$ A_llist$) Bool)
(declare-fun append$ (A_list$ A_list$) A_list$)
(declare-fun fun_app$ (A_list_bool_fun$ A_list$) Bool)
(declare-fun llist_of$ (A_list$) A_llist$)
(assert (! (forall ((?v0 A_list$)) (! (= (fun_app$ uu$ ?v0) (chain$ r$ (llist_of$ (cons$ x$ (append$ ?v0 (cons$ y$ nil$)))))) :pattern ((fun_app$ uu$ ?v0)))) :named a0))
(assert (! (not (chain$ r$ (llist_of$ (cons$ x$ (append$ (eps$ uu$) (cons$ y$ nil$)))))) :named a1))
(assert (! (chain$ r$ (llist_of$ (cons$ x$ (append$ (eps$ uu$) (cons$ y$ nil$))))) :named a2))
(check-sat)
;;;;(get-proof)
